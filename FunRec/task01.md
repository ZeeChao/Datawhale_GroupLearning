# 1. 推荐系统概述
## 1.1. 推荐系统的意义
推荐系统存在的意义核心在于，将特性不同的信息产物与需求不同的信息消费者进行良性匹配，满足信息消费者和信息生产者各自的诉求，实现双赢，并基于此提升平台（推荐系统载体）的价值，最终达到三赢的局面。

### 1.1.1. 平台
平台是推荐系统的载体。对信息生产者而言，它提供了资源位和曝光量使信息产物有更多的机会被消费者看到。对信息消费者而言，它展示了他们可能感兴趣的物品，进而促进二者的一系列交互（点击、观看、点赞、收藏、评论、下单和支付等），即产生“流量”。

推荐系统的存在使一个网站或者APP的页面拓扑结构从流通性较差的树状结构变成流通性更强的网状结构。在这种结构下，用户触达预期物品的机会大大增加，进而增提升了交互率。

从产品或者业务的角度来看，推荐系统能够最大限度地提升用户渗透并提升用户粘性，进而促进平台商业化的目标增长，最终实现平台自身收益的提升。换句话说，推荐系统可以拓宽其触及到的业务链路的转化漏斗，为平台收益提升提供充足的流量基础。

### 1.1.2. 信息产物与信息生产者
信息产物也就是物品（视频、商品、新闻甚至是其他用户），它是由信息生产者创造或者提供的可能会满足消费者需求的东西。信息生产者可以是视频制作者、商家、媒体甚至是平台自身。

合格的推荐系统会让平台上的物品得到合理的曝光。这里，合理一方面指的是把物品推荐给对的人，另一方面指的是让所有有价值的物品都有机会得到曝光。

任何平台，其物品的分布难免会存在长尾分布的情况。具体来说，平台上大部分的热门物品可能只占所有物品的一小部分比例。而大多数人的需求可能要其他非热门的物品才能满足。

### 1.1.3. 信息消费者
信息消费者更常用的称呼是用户。一个好的推荐系统，不能仅限于满足用户的信息需求，还要尽可能地提升用户的使用体验。这里的用户体验，除了曝光用户满意的物品之外，还包括推荐物品的多样性，用户兴趣的挖掘等。

### 1.1.4. 搜索、广告和推荐的区别
1. 根本上的区别
* 搜索：要解决的关键问题全部围绕用户的query展开。如何围绕query高效获取准确信息是它要解决的根本问题。尽管如今的搜索越来越强调个性化结果。但推荐算法强调的个性化永远只是搜索算法的补充。
* 广告：不管哪家公司，目的只有一个，那就是直接增加公司收入。
* 推荐：尽管也是为了增加公司收入，但是是以一种间接的方法实现的。它更直接的目的是增加用户的参与度或者说是增进用户与物品的交互。交互代表着流量，流量多了，平台的后续商业化目标才更有可能获得增长。

2. 优化目标的区别
* 搜索：使用搜索的用户往往是有明确目的或者是希望得到正确答案的。因此搜索非常看重正确答案的召回情况。因此搜索看重后者优化的目标通常包括召回率、MAP和NDCG等。
* 广告：不管是哪家公司，广告关注的指标都高度统一，就是CTR和CVR。这是因为当前效果类广告的计价方式都高度统一，基本上都离不开点击和进一步转化。因此只有针对二者进行预估才能反向推导出流量的价值。更重要的是，CTR和CVR一般会直接参与后续的决策，这也意味着它们直接与收益和资损挂钩。它们的预估如果有偏差，很有可能导致收益无法最大化甚至是赔钱，因此广告看重的优化目标主要是预估偏差。
* 推荐：推荐算法由于应用场景丰富且不同场景关注内容不同，因此其指标非常多样，例如APP关注渗透和留存，电商关注CTR、CVR和GMV，视频关注平均观看时长、点赞收藏和评论等。其评估更加看重AUC、GAUC等指标。

总而言之，搜索关注“完备性”，广告关注“准确性”，推荐关注“排序性”。

3. 算法设计的区别
* 搜索：关注物品与query的关联性，以及对query的理解。因此，query与其他特征组成的交叉特征和组合特征，以及模型中隐式交叉部分非常重要。对于一些特定场景（例如，搜索引擎等），还要在一定程度上抑制个性化需求，将质量更高或者权威性更高的物品放在靠前的位置。
* 广告：关注CTR和CVR的准确性，用于计算后续出价。因此对准确度的要求更高。此时，仅仅预测广告之间的相对排序位置是难以满足要求的。同时，模型在训练时的一些trick，例如负采样、样本权重和采用特殊的损失函数等，会显著改变原始数据的分布。这也就催生出了校准这一关键技术。另外，由于广告很少是以列表形式连续呈现的，因此多是以point wise的方式进行训练的。
* 推荐：推荐的结果多半是以列表形式呈现的，因此对相对排序位置更加看重，对准确性的要求反而没那么高。有时候，为了让用户的参与度更高，还会关注内容多样性对用户的吸引力。因此推荐算法有很多不同的训练方法，包括但不限于point wise，pair wise和list wise等。此外，为了提升用户的长期参与度，还对推荐内容的多样性和新鲜度有更高的要求，这就让探索和利用，还有强化学习等方法在推荐场景下更受重视。

4. 辅助策略或辅助算法的区别
* 搜索：辅助算法还是聚焦在query的理解上。因此搜索场景应用了很多的NLP模型。
* 广告：预估准确CTR和CVR只是基本前提，如何让广告持续最大化盈利，还需要多个算法模块，例如pacing、biding、budget control和ads allocation等，之间的密切配合。
* 推荐：由于需要考虑用户长期兴趣，因此需要补充一些看似非最优的选择，例如探索性尝试一些长尾内容，在生成列表是加入多样性约束等等。

5. 模型自身的区别
* 搜索：query与物品之间天然是一个双塔结构，因此在模型中各种特征交叉融合的结构是重点。
![alt text](https://pic2.zhimg.com/v2-067e13a072c6519d21565b56decb4b17_1440w.jpg)
* 广告：用户兴趣连贯性不高，因此序列建模效果未必很好，注意力机制的重要性会更高。
* 推荐：用户兴趣连贯性很重要，因此序列建模往往很有必要。
![alt text](https://pic3.zhimg.com/v2-ddd3f8515d95b1489e8046b4acc6fb00_1440w.jpg)

最后要说明的是，上述的很多方法策略并不是某个领域独有的，只不过是在这个领域，该方法更为常用或者更加重要。

### 1.1.5. 推荐系统分类
1. 按技术原理分类

    1.1. 基于内容推荐
    * 原理：分析用户历史行为和物品属性，推荐相似内容。
    * 优势：解决物品冷启动问题，可解释性强。
    * 劣势：难以挖掘用户兴趣，容易陷入信息茧房。
    * 案例：
        * Netflix：基于影片类型、演员等特征推荐相似影视内容。
        * Spotify：根据歌曲流派、节奏特征推荐相似音乐。

    1.2. 协同过滤
    * 子类：
        1. 基于用户：寻找相似用户群体，推荐他们喜欢的物品。
        2. 基于物品：寻找相似物品，将它们推荐给用户。
        3. 基于模型：使用矩阵分解或者其他方法预测用户偏好。
    * 案例：
        * TikTok：基于用户行为和相似用户群推荐短视频。
        * 亚马逊：商品页的“经常一起购买”推荐。

    1.3. 混合推荐
    * 原理：结合所有可用的方法。
    * 案例：
        * YouTube：
            * 召回：GNN分析用户社交关系。
            * 排序：DeepWalk模型，融合视频内容特征与用户行为。
        * 小红书：内容标签匹配，用户社交链协同过滤。

2. 按场景分类

    2.1. 电商
    * 目标：提升转化率和GMV等。
    * 策略：物品协同过滤和跨品类推荐等。
    * 案例：
        * 淘宝
        * 京东
        * 拼多多

    2.2. 社交媒体和内容
    * 目标：提升用户互动率、使用时长和留存率。
    * 策略：用户兴趣图谱，实时热点，社交关系推荐等。
    * 案例：
        * Instagram
        * Facebook
        * 今日头条
    
    2.3. 娱乐流媒体
    * 目标：提升用户使用时长和留存率。
    * 策略：行为序列建模，用户兴趣挖掘。
    * 案例：
        * B站
        * 抖音
        * 快手
        * QQ音乐
        * 网易云音乐

    2.4. 生活服务
    * 目标：提升转化率，GMV和留存率等。
    * 策略：物品协同过滤，上下文特征交叉，时空特征挖掘。
    * 案例：
        * 美团
        * 饿了么
        * 叮咚买菜
    
    2.5. 应用商店和游戏平台
    * 目标：提升应用发现效率和下载量。
    * 策略：个性化展示，搜索优化。
    * 案例：
        * 各种应用商城
        * TapTap

## 1.2. 推荐系统的架构
推荐系统的主要任务是从海量物品中找到用户可能比较感兴趣的。然而，在实际情况下，我们不得不要面对各种取舍，其中包括：
1. 实时性和计算成本的取舍

    随着用户数量和物品数量的增长，模型训练和推理的开销会明显增大。较大的时间开销会严重影响实时反馈，进而破坏用户体验。

2. 推荐效果和计算速度的取舍

    随着用户数量和物品数量的增长，直接对所有可能的用户-物品组合进行评分会变得非常不切实际。

以下会从系统架构和算法架构的角度出发，分别介绍推荐系统是如何进行各种取舍的。

### 1.2.1. 系统架构
为了平衡实时性和计算成本，系统架构在设计时采用了一种分层处理架构。参考Netflix提出的系统架构，可以分为以下几层：
* 离线层：不使用实时数据，不提供实时响应。
* 近线层：使用实时数据，不保证实时响应。
* 在线层：使用实时数据，保证实时响应。

![alt text](https://datawhalechina.github.io/fun-rec/imgs/ch01/ch1.2/image-20220409205047285.png)

![alt text](https://datawhalechina.github.io/fun-rec/imgs/ch01/ch1.2/image-20220409204658032.png)

下面我们仔细介绍一下这三个层。
1. 离线层

    离线层不使用实时数据，不提供实时响应。它是计算量最大的层。主要的作用是做数据存储、数据预处理、特征工程和离线模型训练。

    离线任务一般会以天为单位运行，比如每天晚上定期更新当天的数据然后重新训练模型，第二天再上线。

2. 近线层

    近线层使用实时数据，不保证实时响应。实际上，近线层的实时性属于允许有几分钟延迟的实时性。这种实时性也被称为准实时。它适合处理延时敏感的任务，例如实时训练数据获取、特征实时更新和模型实时训练等。

3. 在线层

    在线层是直接面向用户的层，使用实时数据并保证实时响应。最大的特点是对响应时长容忍度极低。它主要承担的工作有：模型在线服务，快速召回排序，在线特征快速处理，AB实验或分流，运筹优化和策略干预。

### 1.2.2. 算法架构
为了平衡推荐效果和计算速度，算法架构在设计时同样采用了分层处理架构。通常，一个成熟的推荐算法架构，都会包含以下部分：
1. 召回层

    召回层的效果是从亿级的物品中选取万级的物品作为后续模块的输入，追求的快速和完备。因此召回涉及到的模型往往更轻量化，精度也不如后续模块的模型高。

    目前工业界常见的召回范式为多路召回，即站在不同的角度设计多个彼此重合度较低的并行召回链路，最后取它们的并集作为最终的召回结果。

    多路召回常见的各个分支有：
    * 协同过滤：UserCF，ItemCF
    * 内容召回：标签，图像特征
    * 向量召回：双塔模型
    * 行为召回：历史交互序列
    * 热门召回：全局或者分场景的热门物品
    * 地理召回：所在城市，居住地附近的物品
    * 社交召回：社交互动内容
    * 兜底召回
    * 冷启动召回
    * 运营召回

2. 粗排

    粗排的效果是从万级的物品中选取千级的物品作为后续模块的输入，追求对速度和精度的兼顾。

3. 精排

    精排的效果是从千级的物品中选取百级的物品并形成排序候选列表，追求排序的效果。因此排序涉及到的模型，无论是输入的特征，还是具体的模型结构，都很复杂，计算量也很大。可以说，推荐算法的大部分都时间都花在了精排上。

4. 重排

    重排的效果是对精排生成的百级排序候选列表进行重新排序。如果没有后续的混排，那么重排的结果就是最终展示给用户的结果。之所以会有重排这个环节，主要原因是大部分精排模型都是基于point wise优化的，相邻的物品同质化严重，推荐结果可能会缺乏多样性。因此，重排更多是基于list wise进行优化的，其关注指标也从精排的AUC变成了NDCG等更加注重排序效果的指标。

    另外，重排阶段还会插入一些特殊的规则或策略，如强制去重、间隔排序、流量扶持、运营策略、多样性控制和屏蔽降权等。业内做重排主要还是以规则为主，但是现在也逐渐涌现基于模型的重排方法。

5. 混排

    混排的效果是将多个不同的业务线（视频、直播、广告和电商等）或者说多个独立的推荐系统的排序结果进行混合。一般会用到规则策略和强化学习。

## 1.3. 推荐系统的技术栈
### 1.3.1. 画像层
画像主要包括两部分：用户画像和物品画像。画像层属于推荐系统的基础设置，一般每当新的用户或物品加入或者每个一段固定的时间，整个画像层就会做一次更新。

对于用户画像而言，其涵盖的主要内容包括：年龄、性别、职业、兴趣爱好等。这些信息可以从注册信息中直接提取，也可以通过其他间接方式（问卷、行为分析或者模型预测）得到。

对于物品画像而言，其涵盖的内容会更为丰富，除了基础的属性外，还可能会包括很多多模态信息，例如标题embedding、封面embedding、视频embedding、人脸识别结果、OCR、宽高比、清晰度和特殊标签等。

### 1.3.2. 召回层/粗排层
召回层和粗排层存在较大的技术重叠，而且粗排除非流量非常大，否则也可以不用。

召回层常见的模型召回链路有：
1. 经典模型召回

    对用户和物品做embedding编码，然后同时送入模型进行计算。模型的优化目标最好与排序的优化目标一致，避免选出的物品被后续环节轻易淘汰。

    这部分常见的模型有：
    * 双塔模型
    * DeepFM
    * Multi-View DNN

2. 序列模型召回

    通过对用户行为序列建模，得到物品的embedding，再进而得到用户的embedding。物品embedding往往通过基于word2vec或者基于图嵌入的方法得到。而用户embedding则可根据其行为序列以及序列中物品的embedding得到。

    这部分常见的模型有：
    * CBOW
    * Skip-Gram
    * BERT

### 1.3.3. 精排层
精排层模型的演化路径，基本上可以通过下图来总结
![alt text](https://datawhalechina.github.io/fun-rec/imgs/ch01/ch1.3/image-20220410234144149.png)

精排层常见的模型有：
1. 特征交叉模型

    在基于DNN的推荐的早期，很多论文都在聚焦如何提升特征组合和交叉的能力，本质上是希望模型可以摆脱人工先验特征工程，实现一个端到端的模型。不过，工业界的实践印证了，尽管DNN存在理论上的万能近似定理，但是如果想要真正发挥其潜力，显式特征交叉和合理的特征融合模块都是必不可少的。

    这部分常见的模型有：
    * Deep Crossing
    * DCN
    * DeepFM
    * xDeepFM

2. 序列模型

    用户的历史行为序列是非常重要的特征。模型可以从这种特征中挖掘其兴趣偏好以及偏好的变化情况。这种模型中往往离不开RNN模块或者Attention模块。

    这部分常见的模型有
    * DIN
    * DSIN
    * DIEN
    * SIM

3. 多模态信息融合

    多模态除了会为模型提供有价值的特征外，还有利于做物品冷启动。因为，在冷启动的情况下，物品的交互信息可能会非常稀疏，但是其多模态信息不可能是空的。因此可以利用其自带的多模态信息进行学习或者表示。

    这部分常见的工作有
    * Image Matters: Visually modeling user behaviors using Advanced Model Server
    * UMPR

4. 多任务模型

    有时候，在同一个场景下，我们需要学习多种不同预测目标的模型。例如在短视频推荐领域，需要同时考虑CTR、完播率和观看时长等指标。单独优化CTR容易推标题党，单独优化完播率倾向于推短视频，单独优化时长倾向于推长视频。如果每个模型都各自训练容易出现资源浪费和信息利用不充分等情况。由此多任务学习应运而生。
    
    多任务学习的本质是将所有希望优化的指标都放入同一个模型中。多任务模型可以分为上下两部分：上层是各个目标各自的任务塔，下层是它们共享的基座。

    这部分常见的模型有
    * ESSM
    * MMoE
    * CGC
    * PLE
    * DUPN

5. 多场景模型

    有时候，同一个优化目标在同一个APP内或者同一个业务下的多个场景中都是很重要的。如果各自训练难免会出现资源浪费和欠拟合（小流量场景）的情况。多场景学习，就是将不同场景的数据通过合适的方法组织在一起，共同去优化同一个目标。

    这部分常见的模型有
    * PEPNet
    * HMoE
    * HiNet

6. 跨域推荐

    跨域推荐跟多场景学习给人的感觉很类似，都是在利用其他场景的样本辅助训练，提升模型的泛化能力，支持冷启动。但是，多场景学习往往是限定在同一个APP内或者同一个业务下。跨域推荐则是打破了这个限制。

    另外，跨域推荐研究的重点是不同领域的内容要如何选择并进行迁移，以及如何迁移。

    这部分常见的模型有
    * DTCDR
    * MV-DNN
    * EMCDR

7. 强化学习

    强化学习与一般有监督的深度学习相比有一些很显著的优势。
    
    首先强化学习能够比较灵活的定义优化的业务目标，考虑推荐系统长短期的收益，比如用户留存。

    其次是能够体现用户兴趣的动态变化。比如在新闻推荐下，用户兴趣变化很快，强化学习更容易通过用户行为动态产生推荐结果。

    最后是探索利用机制，简单来说就是短期收益和长期收益的权衡。强化学习能够更好的调节这里的回报。

    这部分常见的模型有
    * DQN

### 1.3.4 重排层
由于重排层是基于list wise优化的，其状态空间巨大，因此存在明显的速度问题。而且，重排非常依赖实际的业务场景，因此要做好重排必须要对业务有着很好的理解。

这部分常见的方法有
* MRR
* DPP
* 强化学习
